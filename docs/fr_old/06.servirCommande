Développer la logique métier - Servir la commande

Il faut servir les boissons une fois qu'elles sont commandées.

// module/CoffeeBar/src/CoffeeBar/Event/DrinksServed.php
<?php
namespace CoffeeBar\Event ;
class DrinksServed
{
    protected $id ; // id unique de la note
    protected $drinks ; // array - tableau des numéro d'éléments de menu (int)
}

et l'opération MarkDrinksServed, qui déclenche également un événement 'markDrinksServed'

// module/CoffeeBar/src/CoffeeBar/Command/MarkDrinksServed.php
<?php
namespace CoffeeBar\Command ;
use Zend\EventManager\EventManagerAwareInterface;
use Zend\EventManager\EventManagerInterface;
class MarkDrinksServed implements EventManagerAwareInterface 
{
    protected $id ; // id unique de la note (guid)
    protected $drinks ; // array - liste des numéros d'éléments de menu
    protected $events ; // Zend\EventManager\EventManagerInterface

    // getters & setters

    public function setEventManager(EventManagerInterface $events)
    public function getEventManager()
        
    public function markServed($id, $menuNumbers)
    {
        $this->setId($id) ;
        $this->setDrinks($menuNumbers) ;
        $this->events->trigger('markDrinksServed', '', array('markDrinksServed' => $this)) ;
    }
}

Et l'aggrégat

// module/CoffeeBar/src/CoffeeBar/Service/TabAggregate.php
<?php
class TabAggregate
{
    // les autres méthodes
    ...

    public function attach(EventManagerInterface $events)
    {
        $this->listeners[] = $events->attach('markDrinksServed', array($this, 'onMarkDrinksServed')) ;
        $this->listeners[] = $events->attach('drinksServed', array($this, 'onDrinksServed')) ;
    }

    public function onMarkDrinksServed($events)
    {
        $markDrinksServed = $events->getParam('markDrinksServed') ;
        
        $story = $this->loadStory($markDrinksServed->getId()) ;

        // on vérifie que les boissons ont bien été commandées
        if(!$story->areDrinksOutstanding($markDrinksServed->getDrinks()))
        {
            throw new DrinksNotOutstanding('une ou plusieurs boissons ne font pas parties de la commande') ;
        }
        
        // on déclenche un événement 'drinksServed'
        $drinksServed = new DrinksServed() ;
        $drinksServed->setId($markDrinksServed->getId()) ;
        $drinksServed->setDrinks($markDrinksServed->getDrinks()) ;
        $this->events->trigger('drinksServed', $this, array('drinksServed' => $drinksServed)) ;
    }

    public function onDrinksServed($events)
    {
        $drinksServed = $events->getParam('drinksServed') ;
        
        $story = $this->loadStory($drinksServed->getId()) ;
        foreach($drinksServed->getDrinks() as $drink)
        {
            // on retrouve l'index de l'élément de menu qui est dans le tableau $outstandingDrinks
            $key = $story->getOutstandingDrinks()->getKeyById($drink) ;
            if($key !== null)
            {
                // on récupère le tarif de l'objet OrderedItem qui correspond à l'index identifié plus haut
                $price = $story->getOutstandingDrinks()->offsetGet($key)->getPrice() ;
                // on ajoute le prix de la boisson servie au total (servi) de la note
                $story->addValue($price) ;
                // on décrémente le tableau $outstandingDrinks de la boisson qui a été servie
                $story->getOutstandingDrinks()->offsetUnset($key) ;
            }
        }
        // enregistrement de l'historique dans le cache
        $this->saveStory($drinksServed->getId(), $story) ;
    }
}

Voyons donc nos nouvelles méthodes
TabStory::areDrinksOutstanding($markDrinksServed->getDrinks())
TabStory::addValue($price)

// module/CoffeeBar/src/CoffeeBar/Entity/TabStory/TabStory.php
class TabStory
{
    protected $itemsServedValue ; // float - total des éléments servis
    
    public function __construct()
    {
        $this->itemsServedValue = 0 ;
    }

    public function getItemsServedValue() {
        return $this->itemsServedValue;
    }

    public function addValue($value)
    {
        $this->itemsServedValue += $value ;
        return $this->itemsServedValue ;
    }

    // les autres méthodes

    public function areDrinksOutstanding(array $menuNumbers)
    {
        return $this->areAllInList($menuNumbers, $this->outstandingDrinks) ;
    }
}

L'exception DrinksNotOutstanding

// module/CoffeeBar/src/CoffeeBar/Exception/DrinksNotOutstanding.php
namespace CoffeeBar\Exception ;
use Exception;
class DrinksNotOutstanding extends Exception {}

Contrairement aux boissons qui sont servis une fois commandés, rappelons nous que les plats doivent être servis une fois préparés.

// module/CoffeeBar/src/CoffeeBar/Event/FoodServed.php
<?php
namespace CoffeeBar\Event ;
class FoodServed
{
    protected $id ; // id unique de la note
    protected $food ; // array - tableau des numéro d'éléments de menu (int)
}

et l'opération MarkFoodServed, qui déclenche également un événement 'markFoodServed'

// module/CoffeeBar/src/CoffeeBar/Command/MarkFoodServed.php
<?php
namespace CoffeeBar\Command ;
use Zend\EventManager\EventManagerAwareInterface;
use Zend\EventManager\EventManagerInterface;
class MarkFoodServed implements EventManagerAwareInterface 
{
    protected $id ; // id unique de la note (guid)
    protected $food ; // array - liste des numéros d'éléments de menu
    protected $events ; // Zend\EventManager\EventManagerInterface

    // getters & setters

    public function setEventManager(EventManagerInterface $events)
    public function getEventManager()
        
    public function markServed($id, $menuNumbers)
    {
        $this->setId($id) ;
        $this->setFood($menuNumbers) ;
        $this->events->trigger('markFoodServed', '', array('markFoodServed' => $this)) ;
    }
}

Et l'aggrégat

// module/CoffeeBar/src/CoffeeBar/Service/TabAggregate.php
<?php
class TabAggregate
{
    // les autres méthodes
    ...

    public function attach(EventManagerInterface $events)
    {
        $this->listeners[] = $events->attach('markFoodServed', array($this, 'onMarkFoodServed')) ;
        $this->listeners[] = $events->attach('foodServed', array($this, 'onFoodServed')) ;
    }

    public function onMarkFoodServed($events)
    {
        $markFoodServed = $events->getParam('markFoodServed') ;
        
        $story = $this->loadStory($markFoodServed->getId()) ;

        // on vérifie que les plats ont été préparés
        if(!$story->isFoodPrepared($markFoodServed->getFood()))
        {
            throw new FoodNotPrepared('les plats ne sont pas encore prêts') ;
        }
        
        $foodServed = new FoodServed() ;
        $foodServed->setId($markFoodServed->getId()) ;
        $foodServed->setFood($markFoodServed->getFood()) ;
        $this->events->trigger('foodServed', $this, array('foodServed' => $foodServed)) ;
    }

    public function onFoodServed($events)
    {
        $foodServed = $events->getParam('foodServed') ; 

        $story = $this->loadStory($foodServed->getId()) ;
        
        foreach($foodServed->getFood() as $food)
        {
            // il faut retrouver l'index dans le tableau $preparedFood
            $key = $story->getPreparedFood()->getKeyById($food) ;
           
            if($key !== null)
            {
                // on récupère le prix de l'objet OrderedItem qui correspond à l'index identifié plus haut
                $price = $story->getPreparedFood()->offsetGet($key)->getPrice() ;
                $story->addValue($price) ;
                // on décrémente le tableau $preparedFood
                $story->getPreparedFood()->offsetUnset($key) ;
            }
        }
        $this->saveStory($foodServed->getId(), $story) ;
    }
}

Voyons donc nos nouvelles méthodes
TabStory::isFoodPrepared($markFoodServed->getFood())

// module/CoffeeBar/src/CoffeeBar/Entity/TabStory/TabStory.php
class TabStory
{
    // les autres méthodes

    public function isFoodPrepared(array $menuNumbers)
    {
        return $this->areAllInList($menuNumbers, $this->preparedFood) ;
    }
}

L'exception FoodNotPrepared

// module/CoffeeBar/src/CoffeeBar/Exception/FoodNotPrepared.php
namespace CoffeeBar\Exception ;
use Exception;
class FoodNotPrepared extends Exception {}

Et voilà.
Il reste à gérer les annulations de plats et/ou de boissons (cette partie n'est pas traitée). Le principe est le même, il suffit de créer les événements et les commandes qui vont bien et vérifier que les produits peuvent encore être annulés. Pour le callback de l'opération, il faut éventuellement charger l'historique de la note si nécessaire et pour le callback de l'événement, il faut systématiquement charger l'historique et le mettre à jour. 
Dans le prochain article, on traitera de la clôture de la note.
