Développer la logique métier - Passer commande

Plusieurs éléments entrent dans cette étape. Lors d'une commande, il y a plusieurs plats et boissons qui peuvent être commandés. Nous utilisons tout d'abord une classe intermédiaire qui représente un élément du menu commandé, sans distinguer une boisson d'un plat.

// module/CoffeeBar/src/CoffeeBar/Entity/TabStory/OrderedItem.php
<?php
namespace CoffeeBar\Entity\TabStory ;
class OrderedItem
{
    protected $id ; // int Menu number
    protected $description ; // string Nom de l'élément de menu
    protected $price ; // float
    protected $isDrink ; // bool - Si l'élément de menu est une boisson ou pas

    // ajoutez les getters et les setters
}

 Une fois que nous aurons la liste des éléments de menu commandés, nous pourrons établir par commande la liste des boissons commandées et la liste des plats commandés.

// module/CoffeeBar/src/CoffeeBar/Event/DrinksOrdered.php
<?php
namespace CoffeeBar\Event ;
use CoffeeBar\Entity\TabStory\OrderedItems;
class DrinksOrdered
{
    protected $id ; // guid - id unique de la note
    protected $items ; // CoffeeBar\Entity\TabStory\OrderedItems
}

// module/CoffeeBar/src/CoffeeBar/Event/FoodOrdered.php
<?php
namespace CoffeeBar\Event ;
use CoffeeBar\Entity\TabStory\OrderedItems;
class FoodOrdered
{
    protected $id ; // guid - id unique de la note
    protected $items ; // CoffeeBar\Entity\TabStory\OrderedItems
}

CoffeeBar\Entity\TabStory\OrderedItems hérite de ArrayObject et est un tableau d'objet de type OrderedItem (vu plus haut)

// module/CoffeeBar/src/CoffeeBar/Entity/TabStory/OrderedItems.php
<?php
namespace CoffeeBar\Entity\TabStory ;
use ArrayObject;
class OrderedItems extends ArrayObject
{
}

Nous avons enfin l'opération PlaceOrder. Ici encore, l'objet PlaceOrder déclenche un événement PlaceOrder qui doit être intercepté par notre TabAggregate. Il faut donc donner accès au gestionnaire d'événements. 

// module/CoffeeBar/src/CoffeeBar/Command/PlaceOrder.php
<?php
namespace CoffeeBar\Command ;
use Zend\EventManager\EventManagerAwareInterface;
use Zend\EventManager\EventManagerInterface;
class PlaceOrder implements EventManagerAwareInterface 
{
    protected $id ; // int
    protected $items ; // CoffeeBar\Entity\TabStory\OrderedItems
    protected $events ;

    // ajouter getters et setters

    // la fonction est nominative. Nous n'allons pas hydrater l'objet placeOrder.
    public function placeOrder($id, $items)
    {
        $this->setId($id) ;
        $this->setItems($items) ;
        $this->events->trigger('placeOrder', '', array('placeOrder' => $this)) ;
    }

    // méthode obligatoire pour l'interface EventManagerAwareInterface
    public function setEventManager(EventManagerInterface $events)
    {
        $this->events = $events;
        return $this;
    }
     
    // méthode obligatoire pour l'interface EventManagerAwareInterface
    public function getEventManager()
    {
        return $this->events;
    }
}

Et, mettons tout cela ensemble dans notre aggrégat

// module/CoffeeBar/src/CoffeeBar/Service/TabAggregate.php
<?php
class TabAggregate
{
    // les autres méthodes
    ...

    public function attach(EventManagerInterface $events)
    {
        // si l'événement 'placeOrder' est déclenché, la méthode TabAggregate::onPlaceOrder() s'exécute
        $this->listeners[] = $events->attach('placeOrder', array($this, 'onPlaceOrder')) ;
    }
    
    public function onPlaceOrder($events)
    {
        $placeOrder = $events->getParam('placeOrder') ;

        // chargement de l'historique de la note en utilisant l'id unique
        $story = $this->loadStory($placeOrder->getId()) ;
 
        // on vérifie si la note n'est pas encore ouverte, on retourne une exception
        if(!$story->isTabOpened())
        {
            throw new TabNotOpen('Tab is not open yet') ; // CoffeeBar\Exception\TabNotOpen
        // sinon, on commande les boissons et les plats
        } else {
            $this->orderDrink($placeOrder) ;
            $this->orderFood($placeOrder) ;
        }
    }

    protected function orderDrink(PlaceOrder $order)
    {
        // pour chacun des éléments de menu de type OrderedItem dans l'objet PlaceOrder, 
        // on vérifie si c'est une boisson ou pas
        // $order->getItems() retourne un objet de type OrderedItems
        $drinks = $order->getItems()->getDrinkableItems() ;
        // s'il y a des boissons commandées, on retourne un objet DrinksOrdered()
        // et on déclenche un événement 'drinksOrdered'
        if(count($drinks) != 0)
        {
            $orderedDrinks = new DrinksOrdered() ;
            $orderedDrinks->setId($order->getId()) ;
            $orderedDrinks->setItems($drinks) ;
            $this->events->trigger('drinksOrdered', $this, array('drinksOrdered' => $orderedDrinks)) ;
        }
    }
    
    // même logique pour les plats
    protected function orderFood(PlaceOrder $order)
    {
        $foods = $order->getItems()->getEatableItems() ;
        if(count($foods) != 0)
        {
            $orderedFoods = new FoodOrdered() ;
            $orderedFoods->setId($order->getId()) ;
            $orderedFoods->setItems($foods) ;
            $this->events->trigger('foodOrdered', $this, array('foodOrdered' => $orderedFoods)) ;
        }
    }
}

Nous avons déclenché deux événements de plus : drinksOrdered et foodOrdered. Il faut mettre l'aggrégat à jour.

// module/CoffeeBar/src/CoffeeBar/Service/TabAggregate.php
<?php
class TabAggregate
{
    ...
    public function attach(EventManagerInterface $events)
    {
        $this->listeners[] = $events->attach('drinksOrdered', array($this, 'onDrinksOrdered')) ;
        $this->listeners[] = $events->attach('foodOrdered', array($this, 'onFoodOrdered')) ;
    }

    public function onDrinksOrdered($events)
    {
        $drinksOrdered = $events->getParam('drinksOrdered') ;
        
        $story = $this->loadStory($drinksOrdered->getId()) ;
        // nouvelle méthode : 
        // où on liste les boissons commandées dans l'historique de la note
        $story->addOutstandingDrinks($drinksOrdered->getItems()) ;
        $this->saveStory($drinksOrdered->getId(), $story) ;
    }
    
    public function onFoodOrdered($events)
    {
        $foodOrdered = $events->getParam('foodOrdered') ;
        
        $story = $this->loadStory($foodOrdered->getId()) ;
        // nouvelle méthode :
        // où on liste les plats commandés dans l'historique de la note
        $story->addOutstandingFood($foodOrdered->getItems()) ;
        $this->saveStory($foodOrdered->getId(), $story) ;
    }
}

Pour compléter notre code, il nous reste les méthodes 
OrderedItems::getDrinkableItems() ;
OrderedItems::getEatableItems() ;
TabStory::addOutstandingDrinks($drinksOrdered->getItems())
TabStory::addOutstandingFood($foodOrdered->getItems())
Et l'exception TabNotOpen

// module/CoffeeBar/src/CoffeeBar/Entity/TabStory/OrderedItems.php
class OrderedItems
{
    // les autres méthodes

    public function getDrinkableItems()
    {
        $iterator = $this->getIterator() ;
        $items = new OrderedItems() ;
        // $item de type CoffeeBar\Entity\TabStory\OrderedItem
        foreach($iterator as $item)
        {
            if($item->getIsDrink())
            {
                $items->offsetSet(NULL, $item) ;
            }
        }
        return $items ;
    }
    
    public function getEatableItems()
    {
        $iterator = $this->getIterator() ;
        $items = new OrderedItems() ;
        // $item de type CoffeeBar\Entity\TabStory\OrderedItem
        foreach($iterator as $item)
        {
            if(!$item->getIsDrink())
            {
                $items->offsetSet(NULL, $item) ;
            }
        }
        return $items ;
    }
}

// module/CoffeeBar/src/CoffeeBar/Entity/TabStory/TabStory.php
class TabStory
{
    /**
     * liste des boissons commandées, non servies
     * @var CoffeeBar\Entity\TabStory\OrderedItems
     */
    protected $outstandingDrinks ; 
    
    /**
     * liste des plats commandés, non servis
     * @var CoffeeBar\Entity\TabStory\OrderedItems
     */
    protected $outstandingFood ;

    public function __construct()
    {
        $this->outstandingDrinks = new OrderedItems() ;
        $this->outstandingFood = new OrderedItems() ;
    }

    // les autres méthodes

    public function addOutstandingDrinks($drinks)
    {
        foreach($drinks as $drink)
        {
            // ajouter des éléments $drink dans un objet ArrayObject
            // offsetSet() est une méthode de l'objet ArrayObject
            $this->outstandingDrinks->offsetSet(NULL, $drink) ;
        }
    }

    public function addOutstandingFood($food)
    {
        foreach($food as $item)
        {
            // ajouter des éléments $item dans un objet ArrayObject
            // offsetSet() est une méthode de l'objet ArrayObject
            $this->outstandingFood->offsetSet(NULL, $item) ;
        }
    }
}

// module/CoffeeBar/src/CoffeeBar/Exception/TabNotOpen.php
namespace CoffeeBar\Exception ;
use Exception;
class TabNotOpen extends Exception {}

Et voila... 
Nous avons désormais notre historique de note (TabStory) qui sait ce qu'il s'est passé sur la note et qui a une propriété qui liste les boissons et les plats commandés mais non servis.
Voyons pour la préparation des plats.

