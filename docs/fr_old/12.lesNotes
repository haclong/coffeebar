A partir de là, nous pouvons commencer à ajouter plus d'interaction entre les notes ouvertes et le staff.

Liste des notes ouvertes

Par exemple, on pourrait vouloir consulter la liste des notes actives.

// module/CoffeeBar/src/CoffeeBar/Controller/TabController.php
<?php
namespace CoffeeBar\Controller ;
class TabController extends AbstractActionController
{
    public function listOpenedAction()
    {
        $cache = $this->serviceLocator->get('TabCache') ;
        $openTabs = $cache->getOpenTabs() ;
        return array('result' => $openTabs) ;
    }
}

La vue

// module/CoffeeBar/view/coffee-bar/tab/list-opened.phtml
<h1>Notes ouvertes</h1>

<table>
    <tr><th>Serveur</th><th>Table</th><th></th></tr>
    <?php
        foreach($result as $k => $v)
        {
            echo "<tr>" ;
            echo "<td>" .$v->getWaiter(). "</td>" ;
            echo "<td>" .$v->getTableNumber(). "</td>" ;
            echo "<td><a href='".$this->url('tab/status', array('id' => $v->getTableNumber()))."'>Voir le statut</a></td>" ;
            echo "</tr>" ;
        }
    ?>
</table>

Et à partir de là, voir le statut de chacune des notes ouvertes
    
// module/CoffeeBar/src/CoffeeBar/Controller/TabController.php
<?php
namespace CoffeeBar\Controller ;
class TabController extends AbstractActionController
{
    public function statusAction()
    {
        $openTabs = $this->serviceLocator->get('OpenTabs') ;
        $status = $openTabs->statusForTable($this->params()->fromRoute('id')) ;
        return array('result' => $status) ;
    }
}

avec la vue (faites pas attention, je me suis aperçu après coup que mes vues sont un coup en français, un coup en anglais...) :

// module/CoffeeBar/view/coffee-bar/tab/status.phtml
<h1>Tab status</h1>

<h2>Table #<?php echo $result->getTableNumber(); ?></h2>

<div><a href="<?php echo $this->url('tab/order', array('id' => $result->getTableNumber())) ;?>">Order Food/Drink</a></div>

<h3>Items to serve</h3>

<?php
if(count($result->getItemsToServe()) == 0)
{
    echo 'Pas de commande en cours' ;
} else {
?>
<form method='post' action='<?php echo $this->url('tab/markserved') ; ?>'> <!-- mark served action table number-->
<input type='hidden' name='tableNumber' value='<?php echo $result->getTableNumber() ; ?>'/>
    <table>
    <tr>
        <th>Menu #</th>
        <th>Description</th>
        <th>Mark Served</th>
    </tr>
<?php
    $i = 0 ;
    foreach($result->getItemsToServe() as $k=> $v)
    {
        echo "<tr>" ;
        echo "<td>" .$v->getMenuNumber(). "</td>" ;
        echo "<td>" .$v->getDescription() . "</td>" ;
        echo "<td><input type='checkbox' name='served[]' value='menu_" .$i++. "_" .$v->getMenuNumber(). "'/></td>" ;
        echo "</tr>" ;
    }
?>
</table>
    <input type='submit' value='Mark served'/>
</form>
<?php
}
?>


<h3>Food in preparation</h3>

<?php
if(count($result->getItemsInPreparation()) == 0)
{
    echo 'Pas de commande en cours' ;
} else {
?>
<table>
    <tr>
        <th>Menu #</th>
        <th>Description</th>
    </tr>
<?php    
    foreach($result->getItemsInPreparation() as $k=> $v)
    {
        echo "<tr>" ;
        echo "<td>" .$v->getMenuNumber(). "</td>" ;
        echo "<td>" .$v->getDescription() . "</td>" ;
        echo "</tr>" ;
    }
?>
</table>
<?php
}
?>



<h3>Items already served</h3>

<?php
if(count($result->getItemsServed()) == 0)
{
    echo 'Pas de commande en cours' ;
} else {
?>
<table>
    <tr>
        <th>Menu #</th>
        <th>Description</th>
    </tr>
<?php    
    foreach($result->getItemsServed() as $k=> $v)
    {
        echo "<tr>" ;
        echo "<td>" .$v->getMenuNumber(). "</td>" ;
        echo "<td>" .$v->getDescription() . "</td>" ;
        echo "</tr>" ;
    }
?>
</table>
<?php
}
?>

Et avec cette vue, nous avons l'étape suivante : servir les boissons, à défaut d'avoir préparé nos plats...

A ce propos, regardez mieux l'action statusAction... oui oui oui, nous avons une méthode inconnue là, qu'on va retrouver dans CoffeeBar\Service\OpenTabs

// module/CoffeeBar/src/CoffeeBar/Service/OpenTabs.php
<?php
namespace CoffeeBar\Service ;
class OpenTabs
{
    /**
     * Retourne le statut de la commande
     * @param int $table - Id de la table
     * @return TabStatus
     */
    public function statusForTable($table)
    {
        $this->loadTodoByTab() ;
        foreach($this->todoByTab->getArrayCopy() as $k => $v)
        {
            if($v->getTableNumber() == $table)
            {
                $status = new TabStatus() ;
                $status->setTabId($k) ;
                $status->setTableNumber($v->getTableNumber()) ;
                $status->setItemsToServe($v->getItemsToServe()) ;
                $status->setItemsInPreparation($v->getItemsInPreparation()) ;
                $status->setItemsServed($v->getItemsServed()) ;
                return $status ;
            }
        }
        return NULL ;
    }
}

Et cette méthode instancie un nouvel objet 

// module/CoffeeBar/src/CoffeeBar/Entity/OpenTabs/TabStatus.php
<?php
namespace CoffeeBar\Entity\OpenTabs ;
use ArrayObject;
class TabStatus
{
    protected $tabId; // int (guid) - id unique de la note
    protected $tableNumber; // int - numéro de la table
    protected $itemsToServe; // ItemsArray (ArrayObject) - liste des éléments à servir
    protected $itemsInPreparation; // ItemsArray (ArrayObject) - liste des éléments en préparation
    protected $itemsServed; // ItemsArray (ArrayObject) - liste des éléments servis

    // getters & setters
}

Le tutoriel d'origine a l'air d'appliquer scrupuleusement la règle suivante : toute méthode retourne invariablement un objet. Ca à l'air systématique. En soit, ça ne me choque pas mais cela génère effectivement un volume conséquent d'objets. Après, cela permet de modifier un objet sans casser toute l'application...

Voyons comment on sert les boissons dans le prochain post.