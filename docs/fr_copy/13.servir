Sur la page du statut de la note, on a construit directement dans la vue un petit formulaire, des cases à cocher pour noter quel élément était servi.

Lorsque le formulaire est posté, on récupère un tableau $array avec le numéro identifiant le menu. 




Les notes actives

// module/CoffeeBar/src/CoffeeBar/Service/OpenTabs.php
<?php
namespace CoffeeBar\Service ;
class OpenTabs implements ListenerAggregateInterface
{
    public function attach(EventManagerInterface $events)
    {
        $this->listeners[] = $events->attach('drinksServed', array($this, 'onDrinksServed')) ;
        $this->listeners[] = $events->attach('foodServed', array($this, 'onFoodServed')) ;
    }

    /**
     * Move the served items from the itemsToServe list to the itemsServed list
     * @param Events $events
     */
    public function onDrinksServed($events)
    {
        $drinksServed = $events->getParam('drinksServed') ;

        // on charge l'objet TodoByTab du cache
        $this->loadTodoByTab() ;
        // on récupère l'objet Tab identifié par l'id unique
        $tab = $this->getTab($drinksServed->getId()) ;
        
        foreach($drinksServed->getDrinks() as $drink)
        {
            // pour chaque boisson servie, on ne récupère que le numéro de menu correspondant
            // il faut pouvoir identifier à quel index se situe cet élément de menu dans la liste des plats à servir
            // on pourra ainsi manipuler les objets ArrayObject à partir du moment où on sait de quel index on parle
            $key = $tab->getItemsToServe()->getKeyByMenuNumber($drink) ;
            if($key !== null)
            {
                // on récupère l'objet TabItem qui se situe à cet index $key dans l'objet ItemsToServe (ArrayObject)
                $value = $tab->getItemsToServe()->offsetGet($key) ;
                // on reprend l'objet extrait de ItemsToServe (ArrayObject) et on le rajoute dans l'objet ItemsServed (ArrayObject)
                $tab->getItemsServed()->addItem($value) ;
                // on supprime l'objet qui était dans les ItemsToServe (ArrayObject)
                $tab->getItemsToServe()->offsetUnset($key) ;
            }
        }
        // on stocke sur le même index (id unique) l'objet Tab mis à jour avec les nouveaux éléments
        $this->todoByTab->offsetSet($drinksServed->getId(), $tab) ;
        $this->saveTodoByTab() ;
    }
    
    /**
     * Move the served items from the itemsToServe list to the itemsServed list
     * @param Events $events
     */
    public function onFoodServed($events)
    {
        $foodServed = $events->getParam('foodServed') ;

        // on charge l'objet TodoByTab du cache
        $this->loadTodoByTab() ;
        // on récupère l'objet Tab identifié par l'id unique
        $tab = $this->getTab($foodServed->getId()) ;
        
        foreach($foodServed->getFood() as $food)
        {
            // pour chaque plat à servir, on ne récupère que le numéro de menu correspondant
            // il faut pouvoir identifier à quel index se situe cet élément de menu dans la liste des plats à servir
            // on pourra ainsi manipuler les objets ArrayObject à partir du moment où on sait de quel index on parle
            $key = $tab->getItemsToServe()->getKeyByMenuNumber($food) ;
            if($key !== null)
            {
                // on récupère l'objet TabItem qui se situe à cet index $key dans l'objet ItemsToServe (ArrayObject)
                $value = $tab->getItemsToServe()->offsetGet($key) ;
                // on reprend l'objet extrait de ItemsToServed (ArrayObject) et on le rajoute dans l'objet ItemsServed (ArrayObject)
                $tab->getItemsServed()->addItem($value) ;
                // on supprime l'objet qui était dans les ItemsToServe (ArrayObject) et qui n'y est plus
                $tab->getItemsToServe()->offsetUnset($key) ;
            }
        }
        // on stocke sur le même index (id unique) l'objet Tab mis à jour avec les nouveaux éléments
        $this->todoByTab->offsetSet($foodServed->getId(), $tab) ;
        $this->saveTodoByTab() ;
    }
}



On arrive à la fin de notre petite application. Il reste à préparer les plats et à encaisser le client pour clore la note.  