Développer la logique métier - Préparer les plats

Les boissons pouvant être servies sans passer par un statut de préparation, nous allons d'abord voir comment on gère cette étape.

Lorsqu'un plat est préparé, il n'est plus nécessaire de savoir son nom ni son prix. D'un point de vue fonctionnel, le chef n'a pas besoin de savoir combien coùte le plat qu'il prépare et le nom est utile mais en code, on peut tout aussi bien conserver juste le numéro de l'élément de menu.

// module/CoffeeBar/src/CoffeeBar/Event/FoodPrepared.php
<?php
namespace CoffeeBar\Event ;
class FoodPrepared
{
    protected $id ; // id unique de la note (guid)
    protected $food ; // array - tableau des numéros d'éléments de menu (int)
    
    // getters et setters
}

Et l'opération MarkFoodPrepared. L'opération déclenche nécessairement un événement.

// module/CoffeeBar/src/CoffeeBar/Command/MarkFoodPrepared.php
<?php
namespace CoffeeBar\Command ;
use Zend\EventManager\EventManagerAwareInterface;
use Zend\EventManager\EventManagerInterface;
class MarkFoodPrepared implements EventManagerAwareInterface
{
    protected $id ; // id unique de la note (guid)
    protected $food ; // array - tableau des numéros d'éléments de menu (int)
    protected $events ; // Zend\EventManager\EventManagerInterface

    // getters et setters

    public function setEventManager(EventManagerInterface $events) {} // toujours la même chose
    public function getEventManager() // toujours la même chose

    public function markPrepared($id, $menuNumbers)
    {
        $this->setId($id) ;
        $this->setFood($menuNumbers) ;
        $this->events->trigger('markFoodPrepared', '', array('markFoodPrepared' => $this)) ;
    }
}

Et, mettons tout cela ensemble dans notre aggrégat

// module/CoffeeBar/src/CoffeeBar/Service/TabAggregate.php
<?php
class TabAggregate
{
    // les autres méthodes
    ...

    public function attach(EventManagerInterface $events)
    {
        $this->listeners[] = $events->attach('markFoodPrepared', array($this, 'onMarkFoodPrepared')) ;
        $this->listeners[] = $events->attach('foodPrepared', array($this, 'onFoodPrepared')) ;
    }

    public function onMarkFoodPrepared($events)
    {
        $markFoodPrepared = $events->getParam('markFoodPrepared') ;
        
        $story = $this->loadStory($markFoodPrepared->getId()) ;

        // on vérifie si les plats préparés ont bien été commandés
        if(!$story->isFoodOutstanding($markFoodPrepared->getFood()))
        {
            throw new FoodNotOutstanding('un ou plusieurs plats n\'ont pas été commandés') ;
        }
        
        // déclenchement de l'événement foodPrepared
        $foodPrepared = new FoodPrepared() ;
        $foodPrepared->setId($markFoodPrepared->getId()) ;
        // ce n'est qu'un tableau de numéro d'élément de menu
        $foodPrepared->setFood($markFoodPrepared->getFood()) ; 

        $this->events->trigger('foodPrepared', $this, array('foodPrepared' => $foodPrepared)) ;
    }

    public function onFoodPrepared($events)
    {
        $foodPrepared = $events->getParam('foodPrepared') ; 
        
        $story = $this->loadStory($foodPrepared->getId()) ;
        
        // $foodPrepared->getFood() = tableau de numéro d'élément de menu
        // $food = numéro d'élément de menu
        foreach($foodPrepared->getFood() as $food)
        {
            // $outstandingFood est de type CoffeeBar\Entity\TabStory\OrderedItems
            // il faut retrouver l'index du plat qui est préparé
            // s'il y en a plusieurs, le premier résultat suffit
            $key = $story->getOutstandingFood()->getKeyById($food) ;
            
            if($key !== null)
            {
                // on récupère l'objet OrderedItem qui correspond à l'index identifié plus haut
                $value = $story->getOutstandingFood()->offsetGet($key) ;
                // on décrémente le tableau $outstandingFood du plat qui est préparé
                // et qui n'est donc plus en attente
                $story->getOutstandingFood()->offsetUnset($key) ;
                // on incrémente le tableau $preparedFood avec les données du plat en cours de préparation
                $story->getPreparedFood()->offsetSet(NULL, $value) ;
            }
        }
        // on sauvegarde les données dans le cache
        $this->saveStory($foodPrepared->getId(), $story) ;
    }

Voyons donc nos nouvelles méthodes
OrderedItems::getKeyById($food) 

// module/CoffeeBar/src/CoffeeBar/Entity/TabStory/OrderedItems.php
class OrderedItems
{
    // les autres méthodes

    public function getKeyById($id)
    {
        $iterator = $this->getIterator() ;
        // value est un objet de type CoffeeBar/Entity/TabStory/OrderedItem.php
        foreach($iterator as $key => $value)
        {
            if($value->getId() == $id) {
                return $key ;
            }
        }
    }
}

TabStory::isFoodOutstanding($markFoodPrepared->getFood())
TabStory::getOutstandingFood() et TabStory::getPreparedFood() retourne chacune un objet de type OrderedItems (hérite de ArrayObject).
Les méthodes OrderedItems::offsetGet($key), OrderedItems::offsetUnset($key), OrderedItems::offsetSet(NULL, $value) sont des méthodes de ArrayObject pour incrémenter, identifier et décrémenter l'objet ArrayObject

// module/CoffeeBar/src/CoffeeBar/Entity/TabStory/TabStory.php
class TabStory
{
    /**
     * liste des plats préparés non servis
     * @var CoffeeBar\Entity\TabStory\OrderedItems
     */
    protected $preparedFood ;
    
    public function __construct()
    {
        $this->preparedFood = new OrderedItems() ;
    }

    // les autres méthodes

    public function isFoodPrepared(array $menuNumbers)
    {
        return $this->areAllInList($menuNumbers, $this->preparedFood) ;
    }
    
    protected function areAllInList(array $want, OrderedItems $have)
    {
        $currentHave = $this->getOrderedItemsId($have) ;
        foreach($want as $item)
        {
            if(($key = array_search($item, $currentHave)) !== false) {
                unset($currentHave[$key]);
            } else {
                return false ;
            }
        }
        return true ;
    }

    protected function getOrderedItemsId(OrderedItems $items)
    {
        $array = array() ;
        foreach($items as $item)
        {
            $array[] = $item->getId() ;
        }
        return $array ;
    }
}

L'exception FoodNotOutstanding

// module/CoffeeBar/src/CoffeeBar/Exception/FoodNotOutstanding.php
namespace CoffeeBar\Exception ;
use Exception;
class FoodNotOutstanding extends Exception {}

Il faut maintenant servir tout ça, boissons et plats