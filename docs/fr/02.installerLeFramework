Installer le framework

Pour commencer notre petite application de gestion des commandes d’un petit café, installons d’abord la base 
de l’application. Pour nous, ce sera le socle MVC basé sur le framework Zend Framework 2.

Je tiens à préciser que les autres frameworks tel que Laravel ou Symfony ont les mêmes fonctionnalités. J'écris ce tutorial pour ZF2 parce que je travaille sur ce framework. Je vous invite à le "traduire" dans votre framework favori si vous le souhaitez.

Prérequis

Installer Zend Framework Skeletton Application. (http://framework.zend.com/manual/2.3/en/user-guide/skeleton-
application.html)

Créer un nouveau module CoffeeBar. Je passe rapidement sur cette partie, vous trouverez la documentation sur 
le site de Zend Framework. (http://framework.zend.com/manual/2.3/en/user-guide/modules.html)

Activer le module dans config/application.config.php
Créer le fichier module/CoffeeBar/Module.php avec ce contenu minimal :

<?php

namespace CoffeeBar ;

class Module
{
    public function getAutoloaderConfig()
    {
       return array(
           'Zend\Loader\StandardAutoloader' => array(
               'namespaces' => array(
                   __NAMESPACE__ => __DIR__ . '/src/' . __NAMESPACE__,
               ),
           ),
       ) ;
    }
   
    public function getConfig()
    {
       return include __DIR__ . '/config/module.config.php' ;
    }
}

Créer le fichier module/CoffeeBar/config/module.config.php avec ce contenu minimal :

<?php

return array() ;

Vérifier que le site fonctionne toujours.

Persistence des données

Après avoir commencer à développer, je me suis aperçu qu'il me manquait un espace pour stocker la liste des notes ouvertes. Une couche de "persistence" où j'aurais pu stocker les informations et les extraire.

Parce que l'exercice est sensé être court, j'ai décidé d'exploiter le cache. D’abord pour nous familiariser avec, et ma foi, pour un petit exercice sans conséquence, je ne vois pas pourquoi on irait s’encombrer avec la couche base de données...

Fort heureusement, même si cela m’a pris un certain temps, voire un temps certain à comprendre un tutoriel trouvé sur le net (http://www.masterzendframework.com/servicemanager/storage-cache-abstract-service-factory-easy-cache-configuration) au sujet du cache dans Zend Framework, une fois que c’est compris, c’est - comme pour le reste - simplissime.

L’Application Skeletton de Zend Framework 2 charge déjà un objet abstract factory pour utiliser le cache. Tout ce qui reste à faire, c’est de le paramétrer et de l’utiliser. Le tutoriel de Matthew Setter propose d’utiliser un service Redis, ou à défaut, d’utiliser les ressources de la machine pour le cache. Pour ma part, je découvre, j’opte pour l’utilisation exclusive des ressources de la machine... N’allons pas trop vite...

Bon, le cache est défini ici :

// module/Application/config/module.config.php
<?php
return array(
   ...
    'service_manager' => array(
        'abstract_factories' => array(
            'Zend\Cache\Service\StorageCacheAbstractServiceFactory',
        ),
    ),

);

Pour le paramétrer, dans un fichier de configuration, celui qui vous plaira. Pour ma part, j’ai choisi le fichier global.php parce que mon cache est en local dans le système de fichiers. S’il y avait des accréditations particulières, il vaut mieux mettre son paramétrage dans les fichiers protégés.


// config/autoload/global.php
<?php
return array(
    'caches' => array(
        'Cache\Persistence' => array(
            'adapter' => 'filesystem',
            'ttl'     => 86400,
            'options' => array(
        // modifier les droits d’accès si nécessaires
                // mod : 775 - owner : user:www-data
                'cache_dir' => __DIR__ . '/../../data/cache/',
            ),
        ),
    ),
);

Le charger dans le service manager

// module/CoffeeBar/Module.php
<?php
namespace CoffeeBar;

use CoffeeBar\Service\TabCacheService;

class Module implements FormElementProviderInterface
{
    public function getConfig() //

    public function getAutoloaderConfig() //

    public function getServiceConfig()
    {
        return array(
            'factories' => array(
                'TabCache' => function($sm) {
                    $cacheService = $sm->get('Cache\Persistence') ;
// parce qu’on veut pouvoir le manipuler un peu, on crée un objet qui va nous servir à ajouter des propriétés et des méthodes si besoin est.
                    $tabCache = new TabCacheService($cacheService) ;
                    return $tabCache ;
                },
            ),
        ) ;
    }
}

Notre objet TabCacheService 

// module/CoffeeBar/src/CoffeeBar/Service/TabCacheService.php
<?php
namespace CoffeeBar\Service ;

class TabCacheService
{
    // notez la propriété protégée et les accesseurs qui nous permettent ainsi de gérer les dépendances. 
    protected $cache ;
    
    public function getCache() {
        return $this->cache;
    }

    // l’injection se fait dans le constructeur : cela permet de rendre l’élément obligatoire au bon fonctionnement de notre service.
    public function __construct($cache) {
        $this->cache = $cache;
    }
}

Bon... parler de persistence des données est exagérée puisque le cache n'a pas pour ambition de stocker les données à vie... Mais cela suffit bien pour nous ici.

Le gestionnaire d'événement

Enfin, paramétrons notre gestionnaire d'événement. 

L’application montée avec Zend Framework comprend un gestionnaire d’événement par défaut. A ma connaissance, toutefois, celui ci n’est pas ‘nommé’ et vaut par défaut pour tout le monde. Il serait toutefois plus propre de créer un gestionnaire d’événement dédié.
// module/CoffeeBar/src/CoffeeBar/Service/TabEventManager.php
<?php
namespace CoffeeBar\Service ;
use Zend\EventManager\EventManager;

class TabEventManager extends EventManager
{
}

et dans le service manager

// module/CoffeeBar/Module.php
<?php
namespace CoffeeBar;
class Module implements FormElementProviderInterface
{
...
    public function getServiceConfig()
    {
        return array(
            'invokables' => array(
                'TabEventManager' => 'CoffeeBar\Service\TabEventManager',
            ),
        ) ;
    }
}
